<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Volumetric Display Simulator - 40x40x20</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Courier New', monospace;
            background: #000;
            color: #0ff;
            overflow: hidden;
        }

        #container {
            display: flex;
            height: 100vh;
        }

        #canvas-container {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        canvas {
            border: 1px solid #0ff;
            cursor: grab;
        }

        canvas:active {
            cursor: grabbing;
        }

        #controls {
            width: 320px;
            background: #0a0a0a;
            border-left: 1px solid #0ff;
            padding: 20px;
            overflow-y: auto;
        }

        h1 {
            font-size: 16px;
            margin-bottom: 20px;
            color: #0ff;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .section {
            margin-bottom: 25px;
        }

        .section-title {
            font-size: 12px;
            color: #0aa;
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .effect-btn {
            width: 100%;
            padding: 10px;
            margin: 5px 0;
            background: #001a1a;
            border: 1px solid #0aa;
            color: #0ff;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            font-size: 11px;
            transition: all 0.2s;
            text-align: left;
        }

        .effect-btn:hover {
            background: #002a2a;
            border-color: #0ff;
        }

        .effect-btn.active {
            background: #0ff;
            color: #000;
            font-weight: bold;
        }

        .control-group {
            margin: 15px 0;
        }

        label {
            display: block;
            font-size: 11px;
            margin-bottom: 5px;
            color: #0aa;
        }

        input[type="range"] {
            width: 100%;
            height: 4px;
            background: #002a2a;
            outline: none;
            border-radius: 2px;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 12px;
            height: 12px;
            background: #0ff;
            cursor: pointer;
            border-radius: 50%;
        }

        input[type="range"]::-moz-range-thumb {
            width: 12px;
            height: 12px;
            background: #0ff;
            cursor: pointer;
            border-radius: 50%;
            border: none;
        }

        .value-display {
            display: inline-block;
            float: right;
            color: #0ff;
            font-size: 11px;
        }

        .stats {
            font-size: 10px;
            color: #0aa;
            margin-top: 20px;
            padding-top: 20px;
            border-top: 1px solid #0aa;
        }

        .stats div {
            margin: 5px 0;
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="canvas-container">
            <canvas id="canvas"></canvas>
        </div>
        <div id="controls">
            <h1>Volumetric Display</h1>

            <div class="section">
                <div class="section-title">Display Info</div>
                <div class="stats">
                    <div>Resolution: 40×40×20</div>
                    <div>Total LEDs: 32,000</div>
                    <div id="active-leds">Active LEDs: 0</div>
                    <div id="fps">FPS: 0</div>
                </div>
            </div>

            <div class="section">
                <div class="section-title">Effects</div>
                <button class="effect-btn active" data-effect="0">1. Rotating Plane Slice</button>
                <button class="effect-btn" data-effect="1">2. Pulsing Sphere</button>
                <button class="effect-btn" data-effect="2">3. Rain/Waterfall</button>
                <button class="effect-btn" data-effect="3">4. Wave Ripple</button>
                <button class="effect-btn" data-effect="4">5. Helix Spiral</button>
                <button class="effect-btn" data-effect="5">6. Corner-to-Corner Sweep</button>
                <button class="effect-btn" data-effect="6">7. Concentric Boxes</button>
                <button class="effect-btn" data-effect="7">8. Starfield Depth</button>
                <button class="effect-btn" data-effect="8">9. Perlin Noise Clouds</button>
                <button class="effect-btn" data-effect="9">10. Layer Sequence</button>
            </div>

            <div class="section">
                <div class="section-title">Parameters</div>

                <div class="control-group">
                    <label>
                        Speed
                        <span class="value-display" id="speed-value">1.0</span>
                    </label>
                    <input type="range" id="speed" min="0.1" max="3" step="0.1" value="1">
                </div>

                <div class="control-group">
                    <label>
                        Density
                        <span class="value-display" id="density-value">0.5</span>
                    </label>
                    <input type="range" id="density" min="0.1" max="1" step="0.05" value="0.5">
                </div>

                <div class="control-group">
                    <label>
                        LED Size
                        <span class="value-display" id="led-size-value">2.5</span>
                    </label>
                    <input type="range" id="led-size" min="1" max="5" step="0.5" value="2.5">
                </div>

                <div class="control-group">
                    <label>
                        Brightness
                        <span class="value-display" id="brightness-value">0.8</span>
                    </label>
                    <input type="range" id="brightness" min="0.2" max="1" step="0.05" value="0.8">
                </div>

                <div class="control-group">
                    <label>
                        Grid Opacity
                        <span class="value-display" id="grid-opacity-value">0.2</span>
                    </label>
                    <input type="range" id="grid-opacity" min="0" max="0.5" step="0.05" value="0.2">
                </div>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        // Display dimensions
        const GRID_X = 40;
        const GRID_Y = 40;
        const GRID_Z = 20;

        // Canvas settings
        const SCALE = 12;
        canvas.width = 900;
        canvas.height = 700;

        // State
        let currentEffect = 0;
        let time = 0;
        let params = {
            speed: 1.0,
            density: 0.5,
            ledSize: 2.5,
            brightness: 0.8,
            gridOpacity: 0.2
        };

        // Camera/rotation
        let rotation = { x: -0.4, y: 0.6 };
        let isDragging = false;
        let lastMouse = { x: 0, y: 0 };

        // FPS tracking
        let lastTime = performance.now();
        let frameCount = 0;
        let fps = 0;

        // Voxel grid
        const voxels = new Array(GRID_X * GRID_Y * GRID_Z).fill(0);

        // Perlin noise helper (simplified)
        class PerlinNoise {
            constructor() {
                this.perm = this.generatePermutation();
            }

            generatePermutation() {
                const p = [];
                for (let i = 0; i < 256; i++) p[i] = i;
                for (let i = 255; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [p[i], p[j]] = [p[j], p[i]];
                }
                return [...p, ...p];
            }

            fade(t) {
                return t * t * t * (t * (t * 6 - 15) + 10);
            }

            lerp(t, a, b) {
                return a + t * (b - a);
            }

            grad(hash, x, y, z) {
                const h = hash & 15;
                const u = h < 8 ? x : y;
                const v = h < 4 ? y : h === 12 || h === 14 ? x : z;
                return ((h & 1) === 0 ? u : -u) + ((h & 2) === 0 ? v : -v);
            }

            noise(x, y, z) {
                const X = Math.floor(x) & 255;
                const Y = Math.floor(y) & 255;
                const Z = Math.floor(z) & 255;

                x -= Math.floor(x);
                y -= Math.floor(y);
                z -= Math.floor(z);

                const u = this.fade(x);
                const v = this.fade(y);
                const w = this.fade(z);

                const A = this.perm[X] + Y;
                const AA = this.perm[A] + Z;
                const AB = this.perm[A + 1] + Z;
                const B = this.perm[X + 1] + Y;
                const BA = this.perm[B] + Z;
                const BB = this.perm[B + 1] + Z;

                return this.lerp(w,
                    this.lerp(v,
                        this.lerp(u, this.grad(this.perm[AA], x, y, z),
                                    this.grad(this.perm[BA], x - 1, y, z)),
                        this.lerp(u, this.grad(this.perm[AB], x, y - 1, z),
                                    this.grad(this.perm[BB], x - 1, y - 1, z))),
                    this.lerp(v,
                        this.lerp(u, this.grad(this.perm[AA + 1], x, y, z - 1),
                                    this.grad(this.perm[BA + 1], x - 1, y, z - 1)),
                        this.lerp(u, this.grad(this.perm[AB + 1], x, y - 1, z - 1),
                                    this.grad(this.perm[BB + 1], x - 1, y - 1, z - 1))));
            }
        }

        const perlin = new PerlinNoise();

        // Particle system for rain effect
        let rainParticles = [];
        function initRainParticles() {
            rainParticles = [];
            const count = Math.floor(200 * params.density);
            for (let i = 0; i < count; i++) {
                rainParticles.push({
                    x: Math.random() * GRID_X,
                    y: Math.random() * GRID_Y,
                    z: Math.random() * GRID_Z,
                    speed: 0.5 + Math.random() * 0.5
                });
            }
        }
        initRainParticles();

        // Starfield particles
        let starParticles = [];
        function initStarParticles() {
            starParticles = [];
            const count = Math.floor(300 * params.density);
            for (let i = 0; i < count; i++) {
                starParticles.push({
                    x: Math.random() * GRID_X,
                    y: Math.random() * GRID_Y,
                    z: Math.random() * GRID_Z,
                    vz: 0.2 + Math.random() * 0.3
                });
            }
        }
        initStarParticles();

        // Effect implementations
        const effects = [
            // 0: Rotating Plane
            (t) => {
                const angle = t * params.speed * 0.5;
                const normal = {
                    x: Math.cos(angle),
                    y: Math.sin(angle),
                    z: 0.3
                };
                const thickness = 2 + params.density * 3;

                for (let x = 0; x < GRID_X; x++) {
                    for (let y = 0; y < GRID_Y; y++) {
                        for (let z = 0; z < GRID_Z; z++) {
                            const cx = x - GRID_X / 2;
                            const cy = y - GRID_Y / 2;
                            const cz = z - GRID_Z / 2;
                            const dist = Math.abs(cx * normal.x + cy * normal.y + cz * normal.z);
                            voxels[x + y * GRID_X + z * GRID_X * GRID_Y] = dist < thickness ? 1 : 0;
                        }
                    }
                }
            },

            // 1: Pulsing Sphere
            (t) => {
                const pulse = (Math.sin(t * params.speed) + 1) / 2;
                const radius = 5 + pulse * (8 + params.density * 5);
                const thickness = 1 + params.density * 2;

                for (let x = 0; x < GRID_X; x++) {
                    for (let y = 0; y < GRID_Y; y++) {
                        for (let z = 0; z < GRID_Z; z++) {
                            const dx = x - GRID_X / 2;
                            const dy = y - GRID_Y / 2;
                            const dz = (z - GRID_Z / 2) * 2;
                            const dist = Math.sqrt(dx * dx + dy * dy + dz * dz);
                            voxels[x + y * GRID_X + z * GRID_X * GRID_Y] =
                                Math.abs(dist - radius) < thickness ? 1 : 0;
                        }
                    }
                }
            },

            // 2: Rain/Waterfall
            (t) => {
                voxels.fill(0);
                rainParticles.forEach(p => {
                    p.z -= p.speed * params.speed * 0.3;
                    if (p.z < 0) {
                        p.z = GRID_Z;
                        p.x = Math.random() * GRID_X;
                        p.y = Math.random() * GRID_Y;
                    }
                    const x = Math.floor(p.x);
                    const y = Math.floor(p.y);
                    const z = Math.floor(p.z);
                    if (x >= 0 && x < GRID_X && y >= 0 && y < GRID_Y && z >= 0 && z < GRID_Z) {
                        voxels[x + y * GRID_X + z * GRID_X * GRID_Y] = 1;
                        // Add trail
                        if (z < GRID_Z - 1 && Math.random() > 0.5) {
                            voxels[x + y * GRID_X + (z + 1) * GRID_X * GRID_Y] = 1;
                        }
                    }
                });
            },

            // 3: Wave Ripple
            (t) => {
                for (let x = 0; x < GRID_X; x++) {
                    for (let y = 0; y < GRID_Y; y++) {
                        const dx = x - GRID_X / 2;
                        const dy = y - GRID_Y / 2;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        const wave = Math.sin(dist * 0.3 - t * params.speed * 2) * (3 + params.density * 5);
                        const zPos = GRID_Z / 2 + wave;

                        for (let z = 0; z < GRID_Z; z++) {
                            voxels[x + y * GRID_X + z * GRID_X * GRID_Y] =
                                Math.abs(z - zPos) < 1.5 ? 1 : 0;
                        }
                    }
                }
            },

            // 4: Helix Spiral
            (t) => {
                voxels.fill(0);
                const numStrands = Math.ceil(2 + params.density * 2);
                const radius = 12 + params.density * 5;
                const thickness = 2;

                for (let strand = 0; strand < numStrands; strand++) {
                    const offset = (strand / numStrands) * Math.PI * 2;
                    for (let z = 0; z < GRID_Z; z++) {
                        const angle = z * 0.4 + t * params.speed * 0.5 + offset;
                        const x = Math.floor(GRID_X / 2 + Math.cos(angle) * radius);
                        const y = Math.floor(GRID_Y / 2 + Math.sin(angle) * radius);

                        for (let dx = -thickness; dx <= thickness; dx++) {
                            for (let dy = -thickness; dy <= thickness; dy++) {
                                const nx = x + dx;
                                const ny = y + dy;
                                if (nx >= 0 && nx < GRID_X && ny >= 0 && ny < GRID_Y) {
                                    voxels[nx + ny * GRID_X + z * GRID_X * GRID_Y] = 1;
                                }
                            }
                        }
                    }
                }
            },

            // 5: Corner-to-Corner Sweep
            (t) => {
                const progress = (Math.sin(t * params.speed * 0.5) + 1) / 2;
                const sweepPos = progress * (GRID_X + GRID_Y + GRID_Z);
                const thickness = 3 + params.density * 4;

                for (let x = 0; x < GRID_X; x++) {
                    for (let y = 0; y < GRID_Y; y++) {
                        for (let z = 0; z < GRID_Z; z++) {
                            const sum = x + y + z;
                            voxels[x + y * GRID_X + z * GRID_X * GRID_Y] =
                                Math.abs(sum - sweepPos) < thickness ? 1 : 0;
                        }
                    }
                }
            },

            // 6: Concentric Boxes
            (t) => {
                const pulse = (Math.sin(t * params.speed) + 1) / 2;
                const numBoxes = Math.ceil(3 + params.density * 3);

                voxels.fill(0);
                for (let box = 0; box < numBoxes; box++) {
                    const size = (box / numBoxes + pulse / numBoxes) * Math.min(GRID_X, GRID_Y) / 2;
                    const zSize = size * 0.5;

                    for (let x = 0; x < GRID_X; x++) {
                        for (let y = 0; y < GRID_Y; y++) {
                            for (let z = 0; z < GRID_Z; z++) {
                                const dx = Math.abs(x - GRID_X / 2);
                                const dy = Math.abs(y - GRID_Y / 2);
                                const dz = Math.abs(z - GRID_Z / 2);

                                if ((Math.abs(dx - size) < 1 && dy <= size && dz <= zSize) ||
                                    (Math.abs(dy - size) < 1 && dx <= size && dz <= zSize) ||
                                    (Math.abs(dz - zSize) < 1 && dx <= size && dy <= size)) {
                                    voxels[x + y * GRID_X + z * GRID_X * GRID_Y] = 1;
                                }
                            }
                        }
                    }
                }
            },

            // 7: Starfield Depth
            (t) => {
                voxels.fill(0);
                starParticles.forEach(p => {
                    p.z -= p.vz * params.speed * 0.5;
                    if (p.z < 0) {
                        p.z = GRID_Z - 1;
                        p.x = Math.random() * GRID_X;
                        p.y = Math.random() * GRID_Y;
                    }
                    const x = Math.floor(p.x);
                    const y = Math.floor(p.y);
                    const z = Math.floor(p.z);
                    if (x >= 0 && x < GRID_X && y >= 0 && y < GRID_Y && z >= 0 && z < GRID_Z) {
                        voxels[x + y * GRID_X + z * GRID_X * GRID_Y] = 1;
                    }
                });
            },

            // 8: Perlin Noise Clouds
            (t) => {
                const scale = 0.15 / params.density;
                const threshold = 0.3 - params.density * 0.2;

                for (let x = 0; x < GRID_X; x++) {
                    for (let y = 0; y < GRID_Y; y++) {
                        for (let z = 0; z < GRID_Z; z++) {
                            const noise = perlin.noise(
                                x * scale,
                                y * scale,
                                z * scale + t * params.speed * 0.1
                            );
                            voxels[x + y * GRID_X + z * GRID_X * GRID_Y] = noise > threshold ? 1 : 0;
                        }
                    }
                }
            },

            // 9: Layer Sequence
            (t) => {
                voxels.fill(0);
                const activeLayer = Math.floor((t * params.speed * 0.5) % GRID_Z);
                const pattern = Math.floor((t * params.speed * 0.3) % 4);

                for (let z = 0; z < GRID_Z; z++) {
                    const layerDist = Math.min(
                        Math.abs(z - activeLayer),
                        Math.abs(z - activeLayer + GRID_Z),
                        Math.abs(z - activeLayer - GRID_Z)
                    );

                    if (layerDist <= 2) {
                        for (let x = 0; x < GRID_X; x++) {
                            for (let y = 0; y < GRID_Y; y++) {
                                let lit = false;

                                if (pattern === 0) { // Grid
                                    lit = (x % 4 === 0 || y % 4 === 0);
                                } else if (pattern === 1) { // Checkerboard
                                    lit = ((x + y) % 2 === 0);
                                } else if (pattern === 2) { // Rings
                                    const dx = x - GRID_X / 2;
                                    const dy = y - GRID_Y / 2;
                                    const dist = Math.sqrt(dx * dx + dy * dy);
                                    lit = Math.floor(dist) % 3 === 0;
                                } else { // Diagonal
                                    lit = (x + y) % 5 === 0;
                                }

                                if (lit && layerDist === 0) {
                                    voxels[x + y * GRID_X + z * GRID_X * GRID_Y] = 1;
                                } else if (layerDist > 0 && Math.random() > 0.7) {
                                    voxels[x + y * GRID_X + z * GRID_X * GRID_Y] = 0.3;
                                }
                            }
                        }
                    }
                }
            }
        ];

        // 3D projection
        function project3D(x, y, z) {
            // Center and scale
            const cx = (x - GRID_X / 2) * SCALE;
            const cy = (y - GRID_Y / 2) * SCALE;
            const cz = (z - GRID_Z / 2) * SCALE;

            // Rotate around X axis
            const rx = cx;
            const ry = cy * Math.cos(rotation.x) - cz * Math.sin(rotation.x);
            const rz = cy * Math.sin(rotation.x) + cz * Math.cos(rotation.x);

            // Rotate around Y axis
            const rrx = rx * Math.cos(rotation.y) + rz * Math.sin(rotation.y);
            const rry = ry;
            const rrz = -rx * Math.sin(rotation.y) + rz * Math.cos(rotation.y);

            // Perspective projection
            const perspective = 800;
            const scale = perspective / (perspective + rrz);

            return {
                x: canvas.width / 2 + rrx * scale,
                y: canvas.height / 2 + rry * scale,
                z: rrz,
                scale: scale
            };
        }

        // Draw grid
        function drawGrid() {
            ctx.strokeStyle = `rgba(0, 255, 255, ${params.gridOpacity})`;
            ctx.lineWidth = 0.5;

            // Draw cube edges
            const corners = [
                [0, 0, 0], [GRID_X, 0, 0], [GRID_X, GRID_Y, 0], [0, GRID_Y, 0],
                [0, 0, GRID_Z], [GRID_X, 0, GRID_Z], [GRID_X, GRID_Y, GRID_Z], [0, GRID_Y, GRID_Z]
            ];

            const edges = [
                [0,1],[1,2],[2,3],[3,0], // bottom
                [4,5],[5,6],[6,7],[7,4], // top
                [0,4],[1,5],[2,6],[3,7]  // sides
            ];

            edges.forEach(([a, b]) => {
                const pa = project3D(...corners[a]);
                const pb = project3D(...corners[b]);
                ctx.beginPath();
                ctx.moveTo(pa.x, pa.y);
                ctx.lineTo(pb.x, pb.y);
                ctx.stroke();
            });

            // Draw grid lines
            if (params.gridOpacity > 0.1) {
                ctx.strokeStyle = `rgba(0, 255, 255, ${params.gridOpacity * 0.3})`;
                const step = 10;

                for (let i = step; i < GRID_X; i += step) {
                    const p1 = project3D(i, 0, 0);
                    const p2 = project3D(i, GRID_Y, 0);
                    const p3 = project3D(i, 0, GRID_Z);
                    const p4 = project3D(i, GRID_Y, GRID_Z);

                    ctx.beginPath();
                    ctx.moveTo(p1.x, p1.y);
                    ctx.lineTo(p2.x, p2.y);
                    ctx.stroke();
                }

                for (let j = step; j < GRID_Y; j += step) {
                    const p1 = project3D(0, j, 0);
                    const p2 = project3D(GRID_X, j, 0);

                    ctx.beginPath();
                    ctx.moveTo(p1.x, p1.y);
                    ctx.lineTo(p2.x, p2.y);
                    ctx.stroke();
                }
            }
        }

        // Render
        function render() {
            // Clear
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Update effect
            effects[currentEffect](time);

            // Draw grid
            drawGrid();

            // Collect and sort voxels by depth
            const points = [];
            let activeLEDs = 0;

            for (let x = 0; x < GRID_X; x++) {
                for (let y = 0; y < GRID_Y; y++) {
                    for (let z = 0; z < GRID_Z; z++) {
                        const val = voxels[x + y * GRID_X + z * GRID_X * GRID_Y];
                        if (val > 0) {
                            const p = project3D(x, y, z);
                            points.push({ ...p, val });
                            activeLEDs++;
                        }
                    }
                }
            }

            // Sort by depth (back to front)
            points.sort((a, b) => a.z - b.z);

            // Draw LEDs
            points.forEach(p => {
                const size = params.ledSize * p.scale;
                const alpha = params.brightness * p.val;

                // Glow effect
                const gradient = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, size * 2);
                gradient.addColorStop(0, `rgba(100, 200, 255, ${alpha})`);
                gradient.addColorStop(0.5, `rgba(0, 150, 255, ${alpha * 0.6})`);
                gradient.addColorStop(1, `rgba(0, 100, 255, 0)`);

                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(p.x, p.y, size * 2, 0, Math.PI * 2);
                ctx.fill();

                // Bright center
                ctx.fillStyle = `rgba(200, 230, 255, ${alpha})`;
                ctx.beginPath();
                ctx.arc(p.x, p.y, size * 0.6, 0, Math.PI * 2);
                ctx.fill();
            });

            // Update stats
            document.getElementById('active-leds').textContent = `Active LEDs: ${activeLEDs}`;

            // Update time
            time += 0.016;

            // FPS
            frameCount++;
            const now = performance.now();
            if (now - lastTime >= 1000) {
                fps = frameCount;
                frameCount = 0;
                lastTime = now;
                document.getElementById('fps').textContent = `FPS: ${fps}`;
            }

            requestAnimationFrame(render);
        }

        // Mouse controls
        canvas.addEventListener('mousedown', (e) => {
            isDragging = true;
            lastMouse = { x: e.clientX, y: e.clientY };
        });

        canvas.addEventListener('mousemove', (e) => {
            if (isDragging) {
                const dx = e.clientX - lastMouse.x;
                const dy = e.clientY - lastMouse.y;
                rotation.y += dx * 0.01;
                rotation.x += dy * 0.01;
                lastMouse = { x: e.clientX, y: e.clientY };
            }
        });

        canvas.addEventListener('mouseup', () => {
            isDragging = false;
        });

        canvas.addEventListener('mouseleave', () => {
            isDragging = false;
        });

        // Effect buttons
        document.querySelectorAll('.effect-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.effect-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                currentEffect = parseInt(btn.dataset.effect);
                time = 0;
            });
        });

        // Parameter controls
        function setupControl(id, param, formatter = (v) => v) {
            const slider = document.getElementById(id);
            const display = document.getElementById(`${id}-value`);

            slider.addEventListener('input', (e) => {
                const val = parseFloat(e.target.value);
                params[param] = val;
                display.textContent = formatter(val);

                // Reinit particles if density changed
                if (param === 'density') {
                    initRainParticles();
                    initStarParticles();
                }
            });
        }

        setupControl('speed', 'speed', v => v.toFixed(1));
        setupControl('density', 'density', v => v.toFixed(2));
        setupControl('led-size', 'ledSize', v => v.toFixed(1));
        setupControl('brightness', 'brightness', v => v.toFixed(2));
        setupControl('grid-opacity', 'gridOpacity', v => v.toFixed(2));

        // Start
        render();
    </script>
</body>
</html>
